// scripts/build-all.ts

import { execSync } from 'node:child_process'
import fs from 'node:fs'
import fsp from 'node:fs/promises'
import path from 'node:path'
import { pathToFileURL } from 'node:url'
import ora from 'ora'
import { rimraf } from 'rimraf'

import type { RegistryItem } from '@/lib/schema'

const spinner = ora('Building registries...').start()

const ROOT = process.cwd()
const REGISTRY_DIR = path.join(ROOT, 'registry')
const OUTPUT_DIR = path.join(ROOT, 'public', 'r', 'styles')
const APP_URL = process.env.VITE_PUBLIC_APP_URL ?? 'http://localhost:3000'

function ensureDir(dir: string) {
  fs.mkdirSync(dir, { recursive: true })
}

async function loadConfig(filePath: string): Promise<RegistryItem | null> {
  const fileUrl = pathToFileURL(filePath).href
  const mod = await import(fileUrl)
  return ((mod.default ?? mod.config ?? mod) as RegistryItem) ?? null
}

async function findAllConfigs(
  baseDir: string,
  excludeRoot = true
): Promise<RegistryItem[]> {
  const results: RegistryItem[] = []

  async function walk(dir: string, isRoot: boolean) {
    const entries = await fsp.readdir(dir, { withFileTypes: true })
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name)
      if (entry.isDirectory()) {
        await walk(fullPath, false)
      } else if (entry.isFile() && entry.name.endsWith('config.ts')) {
        if (excludeRoot && isRoot) continue
        const cfg = await loadConfig(fullPath)
        if (cfg) results.push(cfg)
      }
    }
  }

  await walk(baseDir, true)
  return results
}

async function writeJSON(filePath: string, data: unknown) {
  await fsp.writeFile(filePath, JSON.stringify(data, null, 2), 'utf8')
}

async function buildRegistryIndex(styleName: string, items: RegistryItem[]) {
  let index = `/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-explicit-any */
// @ts-nocheck
// This file is autogenerated by scripts/build-all.ts
// Do not edit this file directly.
import * as React from "react"

export const Index: Record<string, any> = {`

  for (const item of items) {
    const componentPath = item.files?.[0]?.path ? `@/${item.files[0].path}` : ''

    index += `
  "${item.name}": {
    name: "${item.name}",
    description: "${item.description ?? ''}",
    type: "${item.type}",
    registryDependencies: ${JSON.stringify(item.registryDependencies)},
    files: [${item.files?.map((file) => {
      return typeof file === 'string'
        ? `"${file}"`
        : `{
      path: "${file.path}",
      type: "${file.type}",
      target: "${file.target ?? ''}"
    }`
    })}],
    component: ${
      componentPath
        ? `React.lazy(async () => {
      const mod = await import("${componentPath}")
      const exportName = Object.keys(mod).find(
        key => typeof mod[key] === 'function' || typeof mod[key] === 'object'
      ) || item.name
      return { default: mod.default || mod[exportName] }
    })`
        : 'null'
    },
    categories: ${JSON.stringify(item.categories)},
    meta: ${JSON.stringify(item.meta)},
    __style: "${styleName}"
  },`
  }

  index += `
}`

  const indexPath = path.join(REGISTRY_DIR, styleName, '__index__.tsx')
  rimraf.sync(indexPath)
  await fsp.writeFile(indexPath, index, 'utf8')
  return index
}

async function buildGlobalRegistryIndex(styleIndexes: Record<string, string>) {
  let globalIndex = `/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-explicit-any */
// @ts-nocheck
// This file is autogenerated by scripts/build-all.ts
// Do not edit this file directly.
import * as React from "react"\n\n`

  const merged: string[] = []
  let counter = 0

  for (const [styleName, indexContent] of Object.entries(styleIndexes)) {
    const match = indexContent.match(
      /export const Index: Record<string, any> = ({[\s\S]*})/
    )
    if (match) {
      const objContent = match[1].trim()
      merged.push(`// ${styleName}\n${objContent.slice(1, -1)}`) // strip outer {}
      counter++
    }
  }

  globalIndex += `export const Index: Record<string, any> = {${merged.join('\n')}}\n`

  const globalPath = path.join(REGISTRY_DIR, 'registry.index.tsx')
  rimraf.sync(globalPath)
  await fsp.writeFile(globalPath, globalIndex, 'utf8')

  spinner.info(`Global registry.index.tsx built with ${counter} styles`)
}

async function build() {
  if (!fs.existsSync(REGISTRY_DIR)) {
    spinner.fail(`Registry directory not found at ${REGISTRY_DIR}`)
    process.exitCode = 1
    return
  }

  const styles = (await fsp.readdir(REGISTRY_DIR, { withFileTypes: true }))
    .filter((d) => d.isDirectory())
    .map((d) => d.name)

  const styleIndexes: Record<string, string> = {}

  for (const style of styles) {
    spinner.text = `Processing style "${style}"...`
    const styleDir = path.join(REGISTRY_DIR, style)
    const outputDir = path.join(OUTPUT_DIR, style)
    ensureDir(outputDir)

    const mainConfigPath = path.join(styleDir, 'config.ts')
    let mainConfig: RegistryItem | null = null
    if (fs.existsSync(mainConfigPath)) {
      mainConfig = await loadConfig(mainConfigPath)
      if (mainConfig) {
        const registryItem = {
          $schema: 'https://ui.shadcn.com/schema/registry-item.json',
          ...mainConfig,
        }
        await writeJSON(path.join(outputDir, 'style.json'), registryItem)
      }
    }

    const otherConfigs = await findAllConfigs(styleDir, true)
    if (otherConfigs.length > 0) {
      const registryData = {
        $schema: 'https://ui.shadcn.com/schema/registry.json',
        homepage: APP_URL,
        name: `dasar-${style}`,
        items: otherConfigs,
      }
      await writeJSON(path.join(outputDir, 'registry.json'), registryData)

      execSync(
        `bun shadcn build ${path.join(outputDir, 'registry.json')} --output ${outputDir}`
      )

      const idxContent = await buildRegistryIndex(style, otherConfigs)
      styleIndexes[style] = idxContent
    }
  }

  await buildGlobalRegistryIndex(styleIndexes)
  spinner.succeed('All registries built successfully!')
}

await build().catch((err) => {
  spinner.fail(
    `Build failed: ${err instanceof Error ? err.message : String(err)}`
  )
  process.exitCode = 1
})
